import * as Papa from 'papaparse';
import * as XLSX from 'xlsx';
import * as RNFS from 'react-native-fs';
import Share from 'react-native-share';
import { Transaction, Budget, Account } from '../types';

export interface ExportOptions {
  format: 'csv' | 'xlsx';
  dateRange: {
    startDate: string;
    endDate: string;
  };
  includeTransactions: boolean;
  includeBudgets: boolean;
  selectedAccountIds?: string[];
  selectedCategories?: string[];
}

export interface TransactionExportData {
  Date: string;
  Description: string;
  Category: string;
  Amount: string;
  Type: string;
  Account: string;
}

export interface BudgetExportData {
  Category: string;
  'Budgeted Amount': string;
  'Spent Amount': string;
  'Remaining Amount': string;
  'Progress %': string;
  Period: string;
  Currency: string;
}

class ExportService {
  private formatCurrency(amount: number, currency: string = 'USD'): string {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency,
    }).format(amount);
  }

  private formatDate(dateString: string): string {
    return new Date(dateString).toLocaleDateString();
  }

  private filterTransactionsByDateRange(
    transactions: Transaction[],
    startDate: string,
    endDate: string
  ): Transaction[] {
    const start = new Date(startDate);
    const end = new Date(endDate);
    
    return transactions.filter(transaction => {
      const transactionDate = new Date(transaction.date);
      return transactionDate >= start && transactionDate <= end;
    });
  }

  private filterTransactionsByAccounts(
    transactions: Transaction[],
    accountIds?: string[]
  ): Transaction[] {
    if (!accountIds || accountIds.length === 0) {
      return transactions;
    }
    return transactions.filter(transaction => accountIds.includes(transaction.accountId));
  }

  private filterTransactionsByCategories(
    transactions: Transaction[],
    categories?: string[]
  ): Transaction[] {
    if (!categories || categories.length === 0) {
      return transactions;
    }
    return transactions.filter(transaction => categories.includes(transaction.category));
  }

  private transformTransactionsForExport(
    transactions: Transaction[],
    accounts: Account[]
  ): TransactionExportData[] {
    const accountMap = accounts.reduce((acc, account) => {
      acc[account.id] = account.name;
      return acc;
    }, {} as Record<string, string>);

    return transactions.map(transaction => ({
      Date: this.formatDate(transaction.date),
      Description: transaction.description,
      Category: transaction.category,
      Amount: this.formatCurrency(Math.abs(transaction.amount)),
      Type: transaction.type,
      Account: accountMap[transaction.accountId] || 'Unknown Account',
    }));
  }

  private transformBudgetsForExport(budgets: Budget[]): BudgetExportData[] {
    return budgets.map(budget => {
      const remaining = budget.budgetedAmount - budget.spentAmount;
      const progress = (budget.spentAmount / budget.budgetedAmount) * 100;
      
      return {
        Category: budget.category,
        'Budgeted Amount': this.formatCurrency(budget.budgetedAmount, budget.currency),
        'Spent Amount': this.formatCurrency(budget.spentAmount, budget.currency),
        'Remaining Amount': this.formatCurrency(remaining, budget.currency),
        'Progress %': `${progress.toFixed(1)}%`,
        Period: budget.period,
        Currency: budget.currency,
      };
    });
  }

  private async generateCSV(data: any[], filename: string): Promise<string> {
    // Add a header comment with export info
    const timestamp = new Date().toLocaleString();
    const headerComment = `# Financial Data Export\n# Generated on: ${timestamp}\n# Total Records: ${data.length}\n\n`;
    
    const csv = Papa.unparse(data, {
      header: true,
      quotes: true,
    });
    
    const filePath = `${RNFS.DocumentDirectoryPath}/${filename}.csv`;
    const finalContent = headerComment + csv;
    
    await RNFS.writeFile(filePath, finalContent, 'utf8');
    return filePath;
  }

  private async generateXLSX(
    transactionData: TransactionExportData[],
    budgetData: BudgetExportData[],
    filename: string,
    includeTransactions: boolean,
    includeBudgets: boolean
  ): Promise<string> {
    const workbook = XLSX.utils.book_new();
    
    // Add export summary sheet
    const summaryData = [
      ['Export Information'],
      ['Generated on', new Date().toLocaleString()],
      ['Transactions included', includeTransactions ? 'Yes' : 'No'],
      ['Budgets included', includeBudgets ? 'Yes' : 'No'],
      ['Total transactions', transactionData.length],
      ['Total budgets', budgetData.length],
      [''],
      ['Note: This file was generated by Financial Budget App'],
    ];
    
    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Export Info');
    
    if (includeTransactions && transactionData.length > 0) {
      const transactionSheet = XLSX.utils.json_to_sheet(transactionData);
      XLSX.utils.book_append_sheet(workbook, transactionSheet, 'Transactions');
    }
    
    if (includeBudgets && budgetData.length > 0) {
      const budgetSheet = XLSX.utils.json_to_sheet(budgetData);
      XLSX.utils.book_append_sheet(workbook, budgetSheet, 'Budgets');
    }

    // Set workbook properties
    workbook.Props = {
      Title: 'Financial Data Export',
      Subject: 'Financial Budget Data',
      Author: 'Financial Budget App',
      CreatedDate: new Date(),
    };

    const filePath = `${RNFS.DocumentDirectoryPath}/${filename}.xlsx`;
    const wbout = XLSX.write(workbook, { type: 'binary', bookType: 'xlsx' });
    
    await RNFS.writeFile(filePath, wbout, 'ascii');
    return filePath;
  }

  async exportData(
    transactions: Transaction[],
    budgets: Budget[],
    accounts: Account[],
    options: ExportOptions
  ): Promise<{ success: boolean; filePath?: string; error?: string }> {
    try {
      // Filter transactions
      let filteredTransactions = transactions;
      
      if (options.includeTransactions) {
        filteredTransactions = this.filterTransactionsByDateRange(
          transactions,
          options.dateRange.startDate,
          options.dateRange.endDate
        );
        
        filteredTransactions = this.filterTransactionsByAccounts(
          filteredTransactions,
          options.selectedAccountIds
        );
        
        filteredTransactions = this.filterTransactionsByCategories(
          filteredTransactions,
          options.selectedCategories
        );
      }

      // Filter budgets (budgets don't need date filtering as they're period-based)
      let filteredBudgets = budgets;
      if (options.includeBudgets && options.selectedCategories) {
        filteredBudgets = budgets.filter(budget => 
          options.selectedCategories!.includes(budget.category)
        );
      }

      // Transform data for export
      const transactionData = options.includeTransactions 
        ? this.transformTransactionsForExport(filteredTransactions, accounts)
        : [];
        
      const budgetData = options.includeBudgets 
        ? this.transformBudgetsForExport(filteredBudgets)
        : [];

      // Generate filename with timestamp
      const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
      const filename = `financial_export_${timestamp}`;

      let filePath: string;

      if (options.format === 'csv') {
        // For CSV, combine both transaction and budget data
        const combinedData = [
          ...transactionData.map(item => ({ ...item, Type: 'Transaction' })),
          ...budgetData.map(item => ({ ...item, Type: 'Budget' })),
        ];
        filePath = await this.generateCSV(combinedData, filename);
      } else {
        // For XLSX, create separate sheets
        filePath = await this.generateXLSX(
          transactionData,
          budgetData,
          filename,
          options.includeTransactions,
          options.includeBudgets
        );
      }

      return { success: true, filePath };
    } catch (error) {
      console.error('Export failed:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown export error' 
      };
    }
  }

  async shareFile(filePath: string, title: string = 'Export Data'): Promise<{ success: boolean; error?: string }> {
    try {
      const shareOptions = {
        title,
        url: `file://${filePath}`,
        type: filePath.endsWith('.csv') ? 'text/csv' : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      };

      await Share.open(shareOptions);
      return { success: true };
    } catch (error) {
      if (error instanceof Error && error.message === 'User did not share') {
        // User cancelled sharing - this is not an error
        return { success: true };
      }
      console.error('Share failed:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown sharing error' 
      };
    }
  }

  async cleanupTempFiles(): Promise<void> {
    try {
      const files = await RNFS.readDir(RNFS.DocumentDirectoryPath);
      const exportFiles = files.filter(file => 
        file.name.startsWith('financial_export_') && 
        (file.name.endsWith('.csv') || file.name.endsWith('.xlsx'))
      );

      // Keep only the last 5 export files
      if (exportFiles.length > 5) {
        const sortedFiles = exportFiles
          .sort((a, b) => (b.mtime?.getTime() || 0) - (a.mtime?.getTime() || 0))
          .slice(5);

        for (const file of sortedFiles) {
          await RNFS.unlink(file.path);
        }
      }
    } catch (error) {
      console.error('Cleanup failed:', error);
    }
  }
}

export default new ExportService();
